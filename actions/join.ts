"use server";

import { db } from "@/lib/db";
import { hashPassword } from "@/lib/auth-server";
import { InviteStatus } from "@prisma/client";
import { getSupabaseAdmin } from "@/lib/supabase-auth-sync";
import { createHash } from "crypto";

export type InviteDetails = {
  email: string;
  role: string;
  yachtName: string;
  valid: boolean;
  error?: string;
};

/**
 * Get invite details by token
 * Returns yacht name, email, and role if valid
 */
export async function getInviteDetails(token: string): Promise<InviteDetails> {
  try {
    if (!token || token.trim() === "") {
      return {
        email: "",
        role: "",
        yachtName: "",
        valid: false,
        error: "Invalid invitation link",
      };
    }

    const invite = await db.yachtInvite.findUnique({
      where: { token },
      include: {
        yacht: {
          select: {
            name: true,
          },
        },
      },
    });

    if (!invite) {
      return {
        email: "",
        role: "",
        yachtName: "",
        valid: false,
        error: "Invitation not found",
      };
    }

    // Check if invite is expired
    if (invite.expiresAt < new Date()) {
      // Mark as expired in DB
      await db.yachtInvite.update({
        where: { id: invite.id },
        data: { status: InviteStatus.EXPIRED },
      });

      return {
        email: "",
        role: "",
        yachtName: "",
        valid: false,
        error: "This invitation has expired",
      };
    }

    // Check if already accepted
    if (invite.status === InviteStatus.ACCEPTED) {
      return {
        email: "",
        role: "",
        yachtName: "",
        valid: false,
        error: "This invitation has already been accepted",
      };
    }

    // Check if user already exists with this email and yacht
    const existingUser = await db.user.findFirst({
      where: {
        email: invite.email.toLowerCase().trim(),
        yachtId: invite.yachtId,
      },
    });

    if (existingUser) {
      return {
        email: "",
        role: "",
        yachtName: "",
        valid: false,
        error: "A user with this email already exists for this yacht",
      };
    }

    return {
      email: invite.email,
      role: invite.role,
      yachtName: invite.yacht.name,
      valid: true,
    };
  } catch (error) {
    console.error("Error getting invite details:", error);
    return {
      email: "",
      role: "",
      yachtName: "",
      valid: false,
      error: "An error occurred while processing your invitation",
    };
  }
}

export type AcceptInviteResult = {
  success: boolean;
  error?: string;
  message?: string;
};

/**
 * Accept invitation and create user account
 */
export async function acceptInvite(
  token: string,
  password: string,
  fullName: string
): Promise<AcceptInviteResult> {
  try {
    if (!token || token.trim() === "") {
      return {
        success: false,
        error: "Invalid invitation token",
      };
    }

    if (!password || password.length < 8) {
      return {
        success: false,
        error: "Password must be at least 8 characters long",
      };
    }

    if (!fullName || fullName.trim().length === 0) {
      return {
        success: false,
        error: "Full name is required",
      };
    }

    // Find and validate invite
    const invite = await db.yachtInvite.findUnique({
      where: { token },
      include: {
        yacht: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (!invite) {
      return {
        success: false,
        error: "Invitation not found",
      };
    }

    // Check if expired
    if (invite.expiresAt < new Date()) {
      await db.yachtInvite.update({
        where: { id: invite.id },
        data: { status: InviteStatus.EXPIRED },
      });
      return {
        success: false,
        error: "This invitation has expired",
      };
    }

    // Check if already accepted
    if (invite.status === InviteStatus.ACCEPTED) {
      return {
        success: false,
        error: "This invitation has already been accepted",
      };
    }

    // Check if user already exists
    const existingUser = await db.user.findFirst({
      where: {
        email: invite.email.toLowerCase().trim(),
        yachtId: invite.yachtId,
      },
    });

    if (existingUser) {
      return {
        success: false,
        error: "A user with this email already exists",
      };
    }

    // Hash password
    const passwordHash = await hashPassword(password);
    const username = invite.email.split("@")[0];

    // Generate user ID (CUID will be generated by Prisma)
    // Create user in database first
    const user = await db.user.create({
      data: {
        email: invite.email.toLowerCase().trim(),
        username: username,
        passwordHash: passwordHash,
        name: fullName.trim(),
        role: invite.role,
        yachtId: invite.yachtId,
        active: true,
      },
    });

    // Create user in Supabase Auth with the actual password
    const admin = getSupabaseAdmin();
    if (admin) {
      try {
        // Convert NextAuth ID to Supabase UUID format
        const supabaseUserId = getUuidFromUserId(user.id);

        // Create user in Supabase Auth with email confirmed
        const { error: createError } = await admin.auth.admin.createUser({
          id: supabaseUserId,
          email: invite.email.toLowerCase().trim(),
          email_confirm: true, // Auto-confirm email
          password: password, // Use the actual password
          user_metadata: {
            original_nextauth_id: user.id,
            name: fullName.trim(),
            yacht_id: invite.yachtId,
          },
        });

        if (createError) {
          console.error("Failed to create user in Supabase Auth:", createError);
          // Don't fail the entire process if Supabase sync fails
          // User can still login via NextAuth
        }
      } catch (supabaseError) {
        console.error("Error creating user in Supabase Auth:", supabaseError);
        // Continue even if Supabase sync fails
      }
    }

    // Mark invite as accepted
    await db.yachtInvite.update({
      where: { id: invite.id },
      data: { status: InviteStatus.ACCEPTED },
    });

    return {
      success: true,
      message: "Account created successfully! You can now sign in.",
    };
  } catch (error) {
    console.error("Error accepting invite:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to create account",
    };
  }
}

/**
 * Convert NextAuth ID to Supabase UUID format
 * Same function as in supabase-auth-sync.ts
 */
function getUuidFromUserId(userId: string): string {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (uuidRegex.test(userId)) {
    return userId;
  }

  const hash = createHash("sha1").update(userId).digest("hex");
  return [
    hash.substring(0, 8),
    hash.substring(8, 12),
    "5" + hash.substring(13, 16),
    "8" + hash.substring(17, 20),
    hash.substring(20, 32),
  ].join("-");
}

